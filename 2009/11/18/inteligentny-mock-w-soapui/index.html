<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="generator" content="Hugo 0.67.0" />
		<title>Inteligentny mock w SoapUI - Tech ramblings by Marcin</title>

		<meta name="description" content="Któż z nas nie testował WebService&#39;ów, a któż z nas nie używał do tego SoapUI :) Ok, z rzeczami oczywistymi dyskutować nie będę, ale przy okazji jednego projekciku okazało się, że fajnie by było gdyby mój mock potrafił zrobić coś więcej niż tylko odpowiedzieć na nadesłany komunikat.
Oczywiście sam SoapUI posiada dosyć spory wachlarz możliwości, bo może wysłać losowy request spośród wprowadzonych, lub wysyłać wedle sekwencji, itp.
Problem w tym, że moim wysublimowanym życzeniem było aby korelować komunikaty określonego typu na podstawie jednego pola z XMLa - nazwijmy je polem &#34;">


		
	
		




<link rel="stylesheet" href="/css/ui.css">

	
		

		<link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">

		
	</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li><li><a href="/about/">About Me</a></li><li><a href="/map-my-dreams/">Map-My-Dreams</a></li><li><a href="/spotify-cover-viewer/">Spotify-Cover-Viewer</a></li></ul>
</nav>

	</div>
</header>
<main class="container">


<main class="content" role="main">
  <article class="article">
    <h1 class="article-title">Inteligentny mock w SoapUI</h1>
    
    <span class="article-date">2009-11-18</span>
    
    <ul class="article-taxonomy">
                  
      <li>
        <i class="fa fa-category"></i><a href="/categories/IT">IT</a><a href="/categories/Og%C3%B3lne">Ogólne</a>
      </li>
      
    
      
    </ul>
 
    <div class="article-content">
      
<div class='post'>
<p>Któż z nas nie testował WebService'ów, a któż z nas nie używał do tego SoapUI :) Ok, z rzeczami oczywistymi dyskutować nie będę, ale przy okazji jednego projekciku okazało się, że fajnie by było gdyby mój mock potrafił zrobić coś więcej niż tylko odpowiedzieć na nadesłany komunikat.</p>
<EXCERPT><p>Oczywiście sam SoapUI posiada dosyć spory wachlarz możliwości, bo może wysłać losowy request spośród wprowadzonych, lub wysyłać wedle sekwencji, itp.</p>

<p>Problem w tym, że moim wysublimowanym życzeniem było aby korelować komunikaty określonego typu na podstawie jednego pola z XMLa - nazwijmy je polem "X". Jeśli w polu X przyszła wartość, której do tej pory nie widzieliśmy - odpowiedz jednym komunikatem, jeśli ta wartość już została przez nas odebrana (ostatnio :) ), to prześlij trochę inną odpowiedź.</p>

<p>Na pomoc przyszedł mi wbudowany interpreter Grooviego, którym to można oskryptować kilka fragmentów aplikacji, między innymi tworzone MockService.</p>

<p>No cóż, rozwiązaniem mojego problemu okazało się wrzucenie poniższego skryptu do "OnRequest" konkretnego WebService'u.</p>

<code>
<pre>
import groovy.sql.Sql                                                                                                                                        
import java.sql.*;

def url = 'jdbc:oracle:thin:@localhost:1521:XE'
def driver = 'oracle.jdbc.OracleDriver'
def user = 'mnp_data' 
def password = 'mnp_data'

def sql = Sql.newInstance(url, user, password, driver)

def groovyUtils = new com.eviware.soapui.support.GroovyUtils(context)

def holder = groovyUtils.getXmlHolder( mockRequest.requestContent)

holder.declareNamespace("xxx", "http://www.ftang.com/example")

def props = mockRunner.mockService
context.put('props', props);

def _phoneNumber = holder.getNodeValue( "//xxx:number")
log.error(_phoneNumber)

if (_phoneNumber != null) {
    if (context.phoneNumber != _phoneNumber) {
        context.setProperty('phoneNumber', _phoneNumber)
        context.setProperty('responseType', 0)
    } else {
        context.setProperty('responseType', 1)
    }   
    sql.eachRow("select * from cases where phone_number = ?", [_phoneNumber]) { 
            log.error(it)
            context.setProperty("caseId", it['case_id'])
        }  
}

def _getPhoneNumber = { 
    return props.getPropertyValue('phoneNumber')
}
context.setProperty("getPhoneNumber", _getPhoneNumber);

def _getOpenCasesResponse = {
    if(context.get('responseType')==1)
        return "<getOpenCasesResponse/>";
}

context.setProperty("getOpenCasesResponse", _getOpenCasesResponse);
</pre>
</code>

<p>Prawda, że proste? :)</p>

<p>A czy Wy używacie grooviego? A może SoapUI?</p>
</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'><a href="">Adams</a></div>
<div class='content'>
<p>No popatrz, używam SoapUI :) Z groov tego korzystalismy do generowania identyfikatorow, ktore nastepnie trafialy do komunikatow. <br />
<br />
Pozdrowienia od kolegi z akademika :)</p></div>
</div>
</div>

    </div>
 
     <div id="disqus_thread"></div>
<script>
    (function() { 
        var d = document, s = d.createElement('script');
        s.src = '//marcinbloguje.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


      <script id="dsq-count-scr" src="//careerboost.disqus.com/count.js" async></script>


  </article>

</main>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				


<a href="http://marcin.cylke.com.pl/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					Theme used: <a href="https://github.com/yursan9/manis-hugo-theme">Manis</a><br>
					
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
	</body>
</html>

