<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hadoop on Just a blog</title>
    <link>http://marcin.cylke.com.pl/categories/hadoop/</link>
    <description>Recent content in Hadoop on Just a blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Dec 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://marcin.cylke.com.pl/categories/hadoop/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Distributed scans with HBase</title>
      <link>http://marcin.cylke.com.pl/2013/12/10/distributed-scans-with-hbase/</link>
      <pubDate>Tue, 10 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://marcin.cylke.com.pl/2013/12/10/distributed-scans-with-hbase/</guid>
      <description>&lt;p&gt;HBase is by design a columnar store, that is optimized for random reads.
You just ask for a row using rowId as an identifier and you get your
data instantaneously.&lt;/p&gt;

&lt;p&gt;Performing a scan on part or whole table is a completely different thing.
First of all, it is sequential. Meaning it is rather slow, because it
doesn&amp;rsquo;t use all the RegionServers at the same time. It is implemented
that way to realize the contract of Scan command - which has to return
results sorted by key.&lt;/p&gt;

&lt;p&gt;So, how to do this efficiently?&lt;/p&gt;

&lt;p&gt;The usual way of getting data from HBase is with the help of its API,
mainly Scan objects. To accomplish the task I&amp;rsquo;ll use just them. I&amp;rsquo;ll
specify startRow and stopRow, so that each Scan request will be looking
through only part of the key space.&lt;/p&gt;

&lt;p&gt;It is crucial to note, that this whole solution works because of key
sorting properties in HBase. So, HBase scans a table according to ascending key
values. Since keys are of String type, key with value &amp;ldquo;1&amp;rdquo; is smaller
than &amp;ldquo;2&amp;rdquo;, because they are sorted lexicographicly. So, also key with value &amp;ldquo;12345&amp;rdquo; is smaller than &amp;ldquo;2&amp;rdquo;. I&amp;rsquo;ve
leveraged this property so that I&amp;rsquo;ve partitioned my whole key space according to
the first character of the key. In my case keys contain only digits. So I
have 10 ranges:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;null-1&lt;/li&gt;
&lt;li&gt;1-2&lt;/li&gt;
&lt;li&gt;2-3&lt;/li&gt;
&lt;li&gt;3-4&lt;/li&gt;
&lt;li&gt;4-5&lt;/li&gt;
&lt;li&gt;5-6&lt;/li&gt;
&lt;li&gt;6-7&lt;/li&gt;
&lt;li&gt;7-8&lt;/li&gt;
&lt;li&gt;8-9&lt;/li&gt;
&lt;li&gt;9-null&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The speedup comes from the fact, that each range resides in its own
partition. That&amp;rsquo;s right, I&amp;rsquo;ve presplit the table to have 10 partitions.
This corresponds rather nicely with my cluster&amp;rsquo;s setup, because I have
more than 10 RegionServers. So every partition should be on different
RegionServer. It will allow the code to do the requested scan operations
in parallel - giving me this exact performance boost.&lt;/p&gt;

&lt;p&gt;How I&amp;rsquo;ve created the input table:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&lt;/p&gt;

&lt;p&gt;$ create &amp;lsquo;tariff_changes&amp;rsquo;, { NAME =&amp;gt; &amp;lsquo;cf&amp;rsquo;, SPLITS_FILE =&amp;gt; &amp;lsquo;splits.txt&amp;rsquo;, VERSIONS =&amp;gt; 50, MAX_FILESIZE =&amp;gt; 1073741824 }&lt;/p&gt;

&lt;p&gt;$ alter &amp;lsquo;tariff_changes&amp;rsquo;, { NAME =&amp;gt; &amp;lsquo;cf&amp;rsquo;, SPLITS_FILE =&amp;gt; &amp;lsquo;splits.txt&amp;rsquo;, VERSIONS =&amp;gt; 50, MAX_FILESIZE =&amp;gt; 1073741824 }&lt;/p&gt;

&lt;p&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Split file is just something along this lines:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
1
2
3
4
5
6
7
8
9
0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This tells HBase what are the rowKeys starting and ending each of the
partitions.&lt;/p&gt;

&lt;p&gt;Ok, so after this rather lengthy introduction, what the actual code
does? It just spins of a few threads - one for each partition - and runs
a Scan request tailored to that partitions key space. This way, I got a
10x speedup for this particular scan. The execution time went down from
30 minutes to 3 for my use case.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve created an example implementation of this idea. You can find it on
GitHub:
&lt;a href=&#34;https://github.com/zygm0nt/hbase-distributed-search&#34;&gt;https://github.com/zygm0nt/hbase-distributed-search&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Any ideas on how to speed things up even more with HBase?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple HBase ORM</title>
      <link>http://marcin.cylke.com.pl/2013/12/08/simple-hbase-orm/</link>
      <pubDate>Sun, 08 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://marcin.cylke.com.pl/2013/12/08/simple-hbase-orm/</guid>
      <description>&lt;p&gt;When dealing with data stored in HBase, you are quick to come to a
conclusion, that it is extremaly inconvenient to reach to it
via HBase native API. It is very verbose and you always need to convert
between bytes and simple types - a pain.&lt;/p&gt;

&lt;p&gt;While I was working on a project of mine, I thought, why not to easy
those pains and fetch real objects from HBase.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s how this simplistic, hackish ORM came to life. It is no match
for projects like &lt;a href=&#34;https://github.com/impetus-opensource/Kundera&#34;&gt;Kundera&lt;/a&gt;
(a JPA compliant solution), or &lt;a href=&#34;https://code.google.com/p/n-orm/&#34;&gt;n-orm&lt;/a&gt;. Nevertheless, it just suits my needs :)&lt;/p&gt;

&lt;p&gt;Project sources are hosted on GitHub: &lt;a href=&#34;https://github.com/zygm0nt/hbase-annotations&#34;&gt;https://github.com/zygm0nt/hbase-annotations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To make use of this, you need to have an entity class with annotations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@Column - with argument specifying column family and column name, ie.
@Column(&amp;ldquo;cf:column-name&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;@Id - will store row key in this property,&lt;/li&gt;
&lt;li&gt;and optionaly @Value - for Spring Expression Language, in case you
need to perform some extraction on the value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Annotations should be on setter methods.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now you have your model annotated and ready to be fetched from HBase.&lt;/p&gt;

&lt;p&gt;The actual work is done with a service class, that should extend class
&lt;a href=&#34;https://github.com/zygm0nt/hbase-annotations/blob/master/src/main/java/pl/touk/hadoop/hbase/BaseHadoopInteraction.java&#34;&gt;BaseHadoopInteraction&lt;/a&gt; just as class
&lt;a href=&#34;https://github.com/zygm0nt/hbase-annotations/blob/master/src/test/java/pl/touk/hadoop/hbase/SampleHBaseClient.java&#34;&gt;SimpleHBaseClient&lt;/a&gt; does.&lt;/p&gt;

&lt;p&gt;Then it is possible to just call:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/zygm0nt/7863407.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Note that there are more methods you can use on BaseHadoopInteraction.
You can also do:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scan&lt;/li&gt;
&lt;li&gt;scan with key ranges&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What you won&amp;rsquo;t get from this simple ORM is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;automatic object updating,&lt;/li&gt;
&lt;li&gt;nested objects,&lt;/li&gt;
&lt;li&gt;saving to HBase - &amp;lsquo;cause I didn&amp;rsquo;t have a need for that,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hope you&amp;rsquo;ll find this piece of code useful. If you see room for
improvements while staying in project&amp;rsquo;s scope - please drop me a
message.&lt;/p&gt;

&lt;p&gt;And if you are searching for a full-fledged ORM solution for interacting with HBase, just head
straight to Kundera project website :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zookeeper &#43; Curator = Distributed sync</title>
      <link>http://marcin.cylke.com.pl/2013/06/24/zookeeper-curator/</link>
      <pubDate>Mon, 24 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://marcin.cylke.com.pl/2013/06/24/zookeeper-curator/</guid>
      <description>&lt;p class=&#34;c8&#34;&gt;&lt;img height=&#34;300&#34; src=&#34;http://marcin.cylke.com.pl/assets/2013-06-24-zookeeper-curator.jpg&#34;&gt;&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;
    &lt;span&gt;An application developed for one of my recent projects at TouK involved multiple servers. There was a requirement to ensure failover for the system&amp;rsquo;s components. Since I had already a few separate components I didn&amp;rsquo;t want to add more of that, and since there already was a Zookeeper ensemble running - required by one of the services, I&amp;rsquo;ve decided to go that way with my solution.&lt;/span&gt;
&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.v629433u6utf&#34;&gt;&lt;/a&gt;&lt;span&gt;What is Zookeeper?&lt;/span&gt;&lt;/h2&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;Just a crude distributed synchronization framework. However, it implements Paxos-style algorithms (&lt;/span&gt;&lt;span
        class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34; href=&#34;http://en.wikipedia.org/wiki/Paxos_(computer_science)&#34;&gt;http://en.wikipedia.org/wiki/Paxos_(computer_science)&lt;/a&gt;&lt;/span&gt;&lt;span&gt;) to ensure no split-brain scenarios would occur. This is quite an important feature, since I don&amp;rsquo;t have to care about that kind of problems while using this app. You just need to create an ensemble of a couple of its instances - to ensure high availability. It is basically a virtual filesystem, with files, directories and stuff. One could ask why another filesystem? Well this one is a rather special one, especially for distributed systems. The reason why creating all the locking algorithms on top of Zookeeper is easy is its Ephemeral Nodes - which are just files that exist as long as connection for them exists. After it disconnects - such file disappears. &lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;With such paradigms in place it&amp;rsquo;s fairly easy to create some high level algorithms for synchronization.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;Having that in place, it&lt;/span&gt;&lt;span&gt;&amp;nbsp;can&lt;/span&gt;&lt;span&gt;&amp;nbsp;safely integrate multiple services ensuring loose coupling in a distributed way.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.ppqvt63vg53w&#34;&gt;&lt;/a&gt;&lt;span&gt;Zookeeper from developer&amp;rsquo;s POV&lt;/span&gt;
&lt;/h2&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;With all the base services for Zookeeper started, it seems there is nothing else, than just connect to it and start implementing necessary algorithms. Unfortunately, the API is quite basic and offers files and directories abstractions with the addition of different node type (file types) - ephemeral and sequence. It is also possible to watch a node for changes.&lt;/span&gt;
&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.lgfultrxupbf&#34;&gt;&lt;/a&gt;&lt;span&gt;Using bare Zookeeper is hard!&lt;/span&gt;&lt;/h2&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;Creating connections is tedious - and there is lots of things to take care of. Handling an established connection is hard - when establishing connection to ensemble, it&amp;rsquo;s necessary to negotiate a session also. During the whole process a number of exceptions can occur - these are &amp;ldquo;recoverable&amp;rdquo;
    exceptions, that can be gracefully handled and not break the connection.&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p
        class=&#34;c8&#34;&gt;&lt;span&gt;So, Zookeeper API is hard.&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;Even if one is proficient with that API, then there come recipes. The reason for using Zookeeper is to be able to implement some more sophisticated algorithms on top of it. Unfortunately those aren&amp;rsquo;t trivial and it is again quite hard to implement them without bugs.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;And since distributed systems are hard, why would anyone want another difficult to handle tool? &lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.8n72xils1l1f&#34;&gt;&lt;/a&gt;&lt;span&gt;Enter Curator&lt;/span&gt;&lt;/h2&gt;&lt;p
        class=&#34;c8&#34;&gt;&lt;span&gt;Happily, guys from Netflix implemented a nice abstraction for dealing with Zookeeper internals. They called it Curator and use it extensively in the company&amp;rsquo;s environment. Curator offers consistent API for Zookeeper&amp;rsquo;s functionality. It even implements a couple of recipes for distributed systems.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.k63iku7qitza&#34;&gt;&lt;/a&gt;&lt;span&gt;File read/write&lt;/span&gt;&lt;/h2&gt;&lt;p
        class=&#34;c8&#34;&gt;&lt;span&gt;The basic use of Zookeeper is as a distributed configuration repository. For this scenario I only need read/write capabilities, to be able to write and read files from the Zookeeper filesystem. This code snippet writes a sample json to a file on ZK filesystem.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;a href=&#34;#&#34; name=&#34;fb1072a0c295459e23a47b12e8c09952a5ab3768&#34;&gt;&lt;/a&gt;&lt;a href=&#34;#&#34;
                                                                                                      name=&#34;0&#34;&gt;&lt;/a&gt;
&lt;pre&gt;
&lt;code&gt;
EnsurePath ensurePath = new EnsurePath(markerPath);
ensurePath.ensure(client.getZookeeperClient());
String json = “...”;
if (client.checkExists().forPath(statusFile(core)) != null)
     client.setData().forPath(statusFile(core), json.getBytes());
else
     client.create().forPath(statusFile(core), json.getBytes());

&lt;/code&gt;
&lt;/pre&gt;

&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.ikl4cn73c5uw&#34;&gt;&lt;/a&gt;&lt;span&gt;Distributed locking&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;Having multiple systems there may be a need of using an exclusive lock for some resource, or perhaps some big system requires it&amp;rsquo;s components to synchronize based on locks. This &amp;ldquo;recipe&amp;rdquo;
    is an ideal match for those situations.&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;a href=&#34;#&#34;
                                                                                        name=&#34;b0329bbbf14b79ffaba1139881914aea887ef6a3&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;#&#34; name=&#34;1&#34;&gt;&lt;/a&gt;
&lt;pre&gt;
&lt;code&gt;

lock = new InterProcessSemaphoreMutex(client, lockPath);
lock.acquire(5, TimeUnit.MINUTES);
… do sth …
lock.release();

&lt;/code&gt;
&lt;/pre&gt;

&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;&amp;nbsp;(from &lt;/span&gt;&lt;span class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                                                                   href=&#34;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/curator/LockingRemotely.java&#34;&gt;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/curator/LockingRemotely.java&lt;/a&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.ck92kse5nam2&#34;&gt;&lt;/a&gt;&lt;span&gt;Sevice Advertisement&lt;/span&gt;&lt;/h2&gt;&lt;p
        class=&#34;c8&#34;&gt;&lt;span&gt;This is quite an interesting use case. With many small services on different servers it is not wise to exchange ip addresses and ports between them. When some of those services may go down, while other will try to replace them - the task gets even harder. &lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;That&amp;rsquo;s why, with Zookeeper in place, it can be utilised as a registry of existing services.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;If a service starts, it registers into the ServiceRegistry, offering basic information, like it&amp;rsquo;s purpose, role, address, and port. &lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;Services that want to use a specific kind of service request an access to some instance. This way of configuring easily decouples services from their configuration.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;Basically this scenario needs ? steps:&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;
    &lt;span&gt;1. Service starts and registers its presence (&lt;/span&gt;&lt;span class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                                                                                   href=&#34;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/curator/WorkerAdvertiser.java#L44&#34;&gt;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/curator/WorkerAdvertiser.java#L44&lt;/a&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;a href=&#34;#&#34; name=&#34;1c67229d451cd2d82dddaf1fb12af1aed4a8ecb0&#34;&gt;&lt;/a&gt;

&lt;pre&gt;
&lt;code&gt;

ServiceDiscovery&lt;WorkerMetadata&gt; discovery = getDiscovery();
            discovery.start();
            ServiceInstance si = getInstance();
            log.info(si);
            discovery.registerService(si);


&lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;2. Another service - on another host or in another JVM on the same machine tries to discover who is implementing the service (&lt;/span&gt;&lt;span
        class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                      href=&#34;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/curator/WorkerFinder.java#L50&#34;&gt;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/curator/WorkerFinder.java#L50&lt;/a&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;a href=&#34;#&#34; name=&#34;0e430a074ab36c8eea3f84fae3d0cffb400dd281&#34;&gt;&lt;/a&gt;&lt;a href=&#34;#&#34;
                                                                                                      name=&#34;3&#34;&gt;&lt;/a&gt;
&lt;pre&gt;
&lt;code&gt;
instances = discovery.queryForInstances(serviceName);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;The whole concept here is ridiculously simple - the service advertising its presence just stores a file with its whereabouts. The service that is looking for service providers just look into specific directory and read stored definitions.&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c8&#34;&gt;&lt;span&gt;In my example, the structure advertised by services looks like this (+ some getters and constructor - the rest is here: &lt;/span&gt;&lt;span
        class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                      href=&#34;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/model/WorkerMetadata.java&#34;&gt;https://github.com/zygm0nt/curator-playground/blob/master/src/main/java/pl/touk/model/WorkerMetadata.java&lt;/a&gt;&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;a href=&#34;#&#34; name=&#34;c0131478bfab43e60b5e077f3170a172a909d199&#34;&gt;&lt;/a&gt;

&lt;pre&gt;
&lt;code&gt;

public final class WorkerMetadata {
    private final UUID workerId;
    private final String listenAddress;
    private final int listenPort;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.qvt6wa2m15sm&#34;&gt;&lt;/a&gt;&lt;span&gt;Source code&lt;/span&gt;&lt;/h2&gt;&lt;p
        class=&#34;c8&#34;&gt;&lt;span&gt;The above recipes are available in Curator library (&lt;/span&gt;&lt;span class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                                                                                                        href=&#34;http://curator.incubator.apache.org/&#34;&gt;http://curator.incubator.apache.org/&lt;/a&gt;&lt;/span&gt;&lt;span&gt;). Recipes&amp;rsquo;
    usage examples are in my github repo at &lt;/span&gt;&lt;span class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                                                                       href=&#34;https://github.com/zygm0nt/curator-playground&#34;&gt;https://github.com/zygm0nt/curator-playground&lt;/a&gt;&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 class=&#34;c8&#34;&gt;&lt;a name=&#34;h.o1zkosbrwpah&#34;&gt;&lt;/a&gt;&lt;span&gt;Conclusion&lt;/span&gt;&lt;/h2&gt;&lt;p
        class=&#34;c8&#34;&gt;&lt;span&gt;If you&amp;rsquo;re in need of a reliable platform for exchanging data and managing synchronization, and you need to do it in a distributed fashion - just choose Zookeeper. Then add Curator for the ease of using it. Enjoy!&lt;/span&gt;
&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr&gt;&lt;p class=&#34;c1&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&#34;c13&#34; start=&#34;1&#34;&gt;
    &lt;li class=&#34;c7&#34;&gt;&lt;span&gt;image comes from: &lt;/span&gt;&lt;span class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                                                                      href=&#34;http://www.flickr.com/photos/jfgallery/2993361148&#34;&gt;http://www.flickr.com/photos/jfgallery/2993361148&lt;/a&gt;&lt;/span&gt;
    &lt;/li&gt;
    &lt;li class=&#34;c7&#34;&gt;&lt;span&gt;all source code fragments taken from this repo: &lt;/span&gt;&lt;span class=&#34;c5&#34;&gt;&lt;a class=&#34;c0&#34;
                                                                                                    href=&#34;https://github.com/zygm0nt/curator-playground&#34;&gt;https://github.com/zygm0nt/curator-playground&lt;/a&gt;&lt;/span&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Operational problems with Zookeeper</title>
      <link>http://marcin.cylke.com.pl/2013/03/21/zookeeper-tips/</link>
      <pubDate>Thu, 21 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>http://marcin.cylke.com.pl/2013/03/21/zookeeper-tips/</guid>
      <description>

&lt;p&gt;This post is a summary of what has been presented by Kathleen Ting on
StrangeLoop conference. You can watch the original here:
&lt;a href=&#34;http://www.infoq.com/presentations/Misconfiguration-ZooKeeper&#34;&gt;http://www.infoq.com/presentations/Misconfiguration-ZooKeeper&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve decided to put this selection here for quick reference.&lt;/p&gt;

&lt;h2 id=&#34;connection-mismanagement:3dd1934cab1c17d4d4b86e7299da0f63&#34;&gt;Connection mismanagement&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;too many connections&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WARN [NIOServerCxn.Factory: 0.0.0.0/0.0.0.0:2181:NIOServerCnxn$Factory@247] - Too many connections from /xx.x.xx.xxx - max is 60
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;running out of ZK connections?&lt;/li&gt;
&lt;li&gt;set &lt;code&gt;maxClientCnxns=200&lt;/code&gt; in &lt;code&gt;zoo.cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HBase client leaking connections?&lt;/li&gt;
&lt;li&gt;fixed in HBASE-3777, HBASE-4773, HBASE-5466&lt;/li&gt;
&lt;li&gt;manually close connections&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;connection closes prematurely&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR: org.apache.hadoop.hbase.ZooKeeperConnectionException: HBase is able to connect to ZooKeeper but the connection closes immediately.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;in &lt;code&gt;hbase-site.xml&lt;/code&gt; set &lt;code&gt;hbase.zookeeper.recoverable.waittime=30000ms&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pig hangs connecting to HBase&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WARN org.apache.zookeeper.ClientCnxn: Session 0x0 for server null, unexpected error, closing socket connection and attempting reconnect java.net.ConnectionException: Connection refused!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;CAUSE:&lt;/strong&gt; location of ZK quorum is not known to Pig&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;use Pig 10, which includes PIG-2115&lt;/li&gt;
&lt;li&gt;if there is an overlap between TaskTrackers and ZK quorum nodes

&lt;ul&gt;
&lt;li&gt;set &lt;code&gt;hbase.zookeeper.quorum&lt;/code&gt; to final in &lt;code&gt;hbase-site.xml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;otherwise add &lt;code&gt;hbaze.zoopeeker.quorum=hadoophbasemaster.lan:2181&lt;/code&gt; in &lt;code&gt;pig.properties&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;time-mismanagement:3dd1934cab1c17d4d4b86e7299da0f63&#34;&gt;Time mismanagement&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;client session timed out&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INFO org.apache.zookeeper.server.ZooKeeperServer: Expiring session &amp;lt;id&amp;gt;, timeout of 40000ms exceeded
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ZK and HBase need the same session timeout values

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zoo.cfg&lt;/code&gt;: &lt;code&gt;maxSession=Timeout=180000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hbase-site.xml&lt;/code&gt;: &lt;code&gt;zookeeper.session.timeout=180000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;don&amp;rsquo;t co-locate ZK with IO-intense DataNode or RegionServer&lt;/li&gt;
&lt;li&gt;specify right amount of heap and tune GC flags

&lt;ul&gt;
&lt;li&gt;turn on parallel/CMS/incremental GC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clients lose connections&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WARN org.apache.zookeeper.ClientCnxn - Session &amp;lt;id&amp;gt; for server &amp;lt;name&amp;gt;, unexpected error, closing socket connection and attempting reconnect java.io.IOException: Broken pipe
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;don&amp;rsquo;t use SSD drive for ZK transaction log&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;disk-management:3dd1934cab1c17d4d4b86e7299da0f63&#34;&gt;Disk management&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;unable to load database - unable to run quorum server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FATAL Unable to load database on disk !  java.io.IOException: Failed to process transaction type: 2 error: KeeperErrorCode = NoNode for &amp;lt;file&amp;gt; at org.apache.zookeeper.server.persistence.FileTxnSnapLog.restore(FileTxnSnapLog.java:152)!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;archive and wipe &lt;code&gt;/var/zookeeper/version-2&lt;/code&gt; if other two ZK servers
are running&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unable to load database - unreasonable length exception&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FATAL Unable to load database on disk java.io.IOException: Unreasonable length = 1048583 at org.apache.jute.BinaryInputArchive.readBuffer(BinaryInputArchive.java:100)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;server allows a client to set data larger than the server can read from disk&lt;/li&gt;
&lt;li&gt;if a znode is not readable, increase &lt;code&gt;jute.maxbuffer&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;look for &lt;code&gt;&amp;quot;Packet len &amp;lt;xx&amp;gt; is out of range&amp;quot;&lt;/code&gt; in the client log&lt;/li&gt;
&lt;li&gt;increase it by 20%&lt;/li&gt;
&lt;li&gt;set in &lt;code&gt;JVMFLAGS=&amp;quot;-Djute.maxbuffer=yy&amp;quot; bin/zkCli.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;fixed in ZOOKEEPER-1513&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;failure to follow leader&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WARN org.apache.zookeeper.server.quorum.Learner: Exception when following the leader java.net.SocketTimeoutException: Read timed out 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;CAUSE:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;disk IO contention, network issues&lt;/li&gt;
&lt;li&gt;ZK snapshot is too large (lots of ZK nodes)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SOLVE:&lt;/strong&gt;
- reduce IO contention by putting dataDir on dedicated spindle
- increase initLimit on all ZK servers and restart, see
  ZOOKEEPER-1521
- monitor network&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;best-practices:3dd1934cab1c17d4d4b86e7299da0f63&#34;&gt;Best Practices&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;DOs&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;separate spindles for dataDir &amp;amp; dataLogDir&lt;/li&gt;
&lt;li&gt;allocate 3 or 5 ZK servers&lt;/li&gt;
&lt;li&gt;tune garbage collection&lt;/li&gt;
&lt;li&gt;run zkCleanup.sh script via cron&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DON&amp;rsquo;Ts&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dont&amp;rsquo; co-locate ZK with I/O intense DataNode or RegionServer&lt;/li&gt;
&lt;li&gt;don&amp;rsquo;t use SSD drive for ZK transaction log&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You may use Zookeeper as an observer - a non-voting member:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;in zoo.cfg&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peerType=observer
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>After WHUG meeting</title>
      <link>http://marcin.cylke.com.pl/2012/11/30/after-whug/</link>
      <pubDate>Fri, 30 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://marcin.cylke.com.pl/2012/11/30/after-whug/</guid>
      <description>&lt;p&gt;Here are the slides from the talk a gave yesterday. If you have any
questions, please ask.&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34;
data-id=&#34;cc18d5601d60013059a31231381554d7&#34; data-ratio=&#34;1.33333333333333&#34;
src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>WHUG 8. Beyond Hadoop - checking other options</title>
      <link>http://marcin.cylke.com.pl/2012/11/26/whug-8-beyond-hadoop/</link>
      <pubDate>Mon, 26 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://marcin.cylke.com.pl/2012/11/26/whug-8-beyond-hadoop/</guid>
      <description>&lt;p&gt;W najbliższy czwartek - czyli 29.11.2012 - poprowadzę prezentację w
ramach Warsaw Hadoop User Group. Swoją obecność można odklinąć tu
&lt;a href=&#34;http://www.meetup.com/warsaw-hug/&#34;&gt;http://www.meetup.com/warsaw-hug/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A o czym będę mówił? Przeklejka ze strony WHUG:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Marcin skupi się na współpracy ekosystemu Hadoopa z innymi narzędziami.
Pokaże jak prosto i wygodnie przetwarzać grafy i jak stosować podejście
Big Data, w czasie rzeczywistym. Poruszy również temat łatwiejszego
tworzenia algorytmów Map-Reduce&lt;/p&gt;

&lt;p&gt;Będzie to nieco mniej technicza (ale wciąż praktyczna) wycieczka po
obrzeżach tematyki, która jest zwykle poruszana w połączeniu z
Hadoop-em.&lt;/p&gt;

&lt;p&gt;Prezentacja będzie dotyczyć narzędzi takich jak Cascading, Storm, Titan.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zapraszam!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hadoop HA setup</title>
      <link>http://marcin.cylke.com.pl/2012/10/30/hadoop-ha/</link>
      <pubDate>Tue, 30 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://marcin.cylke.com.pl/2012/10/30/hadoop-ha/</guid>
      <description>

&lt;p&gt;With the advent of Hadoop&amp;rsquo;s 2.x version, there finally is a working
High-Availability solution. Even two of those. Now it really is easy to
configure and use those solutions. It no longer require external
components, like
&lt;a href=&#34;http://blog.cloudera.com/blog/2009/07/hadoop-ha-configuration/&#34;&gt;DRBD&lt;/a&gt;.
It all is just neatly packed into Cloudera Hadoop distribution - the
precursor of this solution.&lt;/p&gt;

&lt;p&gt;Read on to find out how to use it.&lt;/p&gt;

&lt;p&gt;The most important weakness of previous Hadoop releases was the
single-point-of-failure, which happend to be NameNode. NameNode as a key
component of every Hadoop cluster, is responsible for managing
filesystem namespace information and block location. Loosing its data results in loosing all the data
stored on DataNodes. HDFS is no longer able to reach for specific files,
or its blocks. This renders your cluster inoperable.&lt;/p&gt;

&lt;p&gt;So it is crucial to be able to detect and counter problems with NameNode.
The most desirable behavior is to have a hot backup, that would ensure
a no-downtime cluster operation. To achieve this, the second NameNode
need to have up-to-date information on filesystem metadata and it needs
to be also up and running. Starting NameNode with existing set of data
may easily take many minutes to parse the actual filesystem state.&lt;/p&gt;

&lt;p&gt;Previously used solution - depoying SecondaryNameNode - was somewhat
flawed. It took long time to recover after failure. It was not a
hot-backup solution, which also added to the problem. Some other
solution was required.&lt;/p&gt;

&lt;p&gt;So, what needed to be made redundant is the edits dir contents and
sending block location maps from each of the DataNodes to NameNodes -
in case of HA deployment - to both NameNodes. This was accomplished in
two steps. The first one with the release of CDH 4 beta - solution based
on sharing edits directory. Than, with CDH 4.1 came quorum based solution.&lt;/p&gt;

&lt;p&gt;Find out how to configure those on your cluster.&lt;/p&gt;

&lt;h2 id=&#34;shared-edits-directory-solution:8d364cd6dcb7b648a710c293387d3c8c&#34;&gt;Shared edits directory solution&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.innovative-labs.com/blog/hadoop_ha-nfs.png&#34; alt=&#34;Hadoop HA - NFS based edits share&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For this kind of setup, there is an assumption, that in a cluster exists
a shared storage directory. It should be deployed using some kind of
network-based filesystem. You could try with NFS or GlusterFS.&lt;/p&gt;

&lt;p&gt;{% gist 3958555  core-site.xml %}&lt;/p&gt;

&lt;p&gt;{% gist 3958555  hdfs-site.xml %}&lt;/p&gt;

&lt;p&gt;This setup is quite OK, as long as you&amp;rsquo;re comfortable with maintaining a
separate service (network storage) for handling the HA state. It seems
error prone to me, because it adds another service which high
availability should be ensured. NFS seems to be a bad choice here,
because AFAIK it does not offer HA out of the box.&lt;/p&gt;

&lt;p&gt;On the other hand, we have GlusterFS, which is a distributed filesystem,
you can deploy on multiple bricks and increase the replication level.&lt;/p&gt;

&lt;p&gt;Nevertheless, it still brings additional burden of another service to
maintain.&lt;/p&gt;

&lt;h2 id=&#34;quorum-based-solution:8d364cd6dcb7b648a710c293387d3c8c&#34;&gt;Quorum based solution&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.innovative-labs.com/blog/hadoop_ha-quorum.png&#34; alt=&#34;Hadoop HA - Quorum based edits share&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With the release of CDH 4.1.0 we are now able to use a much better
integrated solution called JournalNode. Now all the updates are
synchronized through a JournalNode. Each JournalNode have the same data
and all the NameNodes are able to recive filesystem state updates from
that daemons.&lt;/p&gt;

&lt;p&gt;This solution is much more consistent with Hadoop ecosystem.&lt;/p&gt;

&lt;p&gt;Please note, that the config is almost identical to the one needed for
shared edits directory solution. The only difference is the value for
&lt;em&gt;dfs.namenode.shared.edits.dir&lt;/em&gt;. This now points to all the journal
nodes deployed in our cluster.&lt;/p&gt;

&lt;p&gt;{% gist 3973262 core-site.xml %}&lt;/p&gt;

&lt;p&gt;{% gist 3973262 hdfs-site.xml %}&lt;/p&gt;

&lt;h1 id=&#34;infrastructure:8d364cd6dcb7b648a710c293387d3c8c&#34;&gt;Infrastructure&lt;/h1&gt;

&lt;p&gt;In both cases you need to run Zookeeper-based Failover Controller
(&lt;em&gt;hadoop-hdfs-zkfc&lt;/em&gt;). This daemon negotiates which NameNode should
become active and which standby.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not all. Depending on the way you&amp;rsquo;ve choosen to deploy HA you
need to do some other things:&lt;/p&gt;

&lt;h2 id=&#34;shared-edits-dir:8d364cd6dcb7b648a710c293387d3c8c&#34;&gt;Shared edits dir&lt;/h2&gt;

&lt;p&gt;With shared edits dir you need to deploy networked filesystem, and mount
it on your NameNodes. After that you can run your cluster and be happy
with your new HA.&lt;/p&gt;

&lt;h2 id=&#34;quroum-based:8d364cd6dcb7b648a710c293387d3c8c&#34;&gt;Quroum based&lt;/h2&gt;

&lt;p&gt;For QJournal to operate you need to install one new package called
&lt;em&gt;hadoop-hdfs-journalnode&lt;/em&gt;. This provides startup scripts for Journal
Node daemons. Choose at least three nodes that will be responsible for
handling edits state and deploy journal nodes on them.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:8d364cd6dcb7b648a710c293387d3c8c&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Thanks to guys from Cloudera we now can use an enterprise grade High
Availability features for Hadoop. Eliminating the single point of
failure in your cluster is essential for easy maintainability of your
infrastructure.&lt;/p&gt;

&lt;p&gt;Given the above choices, I&amp;rsquo;d suggest using QJournal setup, becasue of
its relatively small impact on the overal cluster architecture. It&amp;rsquo;s
good performance and fairly simple setup enable the users to easily
start using Hadoop in HA setup.&lt;/p&gt;

&lt;p&gt;Are you using Hadoop with HA? What are your impressions?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>